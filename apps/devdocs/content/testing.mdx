---
title: Testing Strategy
description: Comprehensive testing approach for backend and frontend applications using Vitest and Playwright
---

# Testing Strategy

The Omni SaaS platform uses a comprehensive testing strategy to ensure reliability, performance, and user experience across all applications.

## Testing Philosophy

- **Test-driven development**: Write tests before or alongside code
- **Comprehensive coverage**: Unit, integration, and end-to-end tests
- **Fast feedback**: Quick test execution for rapid development
- **Maintainable tests**: Clear, readable, and easy to update tests

## Backend Testing (Vitest)

### Overview

The API server (`omni-server`) uses **Vitest** for all backend testing:

- **Unit tests**: Individual functions and methods
- **Integration tests**: Service layer and database operations
- **API tests**: HTTP endpoints and request/response validation
- **Database tests**: Multi-tenant data isolation and CRUD operations

### Test Structure

```typescript
// File: src/tests/services/user-service.test.ts
describe('UserService', () => {
  beforeEach(async () => {
    // Setup test database
  })

  afterEach(async () => {
    // Cleanup test data
  })

  describe('createUser', () => {
    it('should create user with valid data', async () => {
      const userData = {
        email: 'test@example.com',
        name: 'Test User'
      }
      
      const user = await userService.createUser(userData)
      
      expect(user).toBeDefined()
      expect(user.email).toBe(userData.email)
    })

    it('should throw error for duplicate email', async () => {
      // Test implementation
    })
  })
})
```

### Running Backend Tests

```bash
# Run all backend tests
pnpm test:server

# Run tests in watch mode
pnpm test:server:watch

# Run tests with coverage
pnpm test:server:coverage

# Run specific test file
pnpm test:server user-service.test.ts
```

### Test Categories

#### Unit Tests
- Service methods
- Utility functions
- Data validation
- Error handling

#### Integration Tests
- Database operations
- Redis caching
- Multi-tenant isolation
- Service layer interactions

#### API Tests
- Endpoint functionality
- Request validation
- Response formatting
- Authentication flows

## Frontend Testing (Playwright)

### Overview

Both client applications (`omni-client` and `omni-admin`) use **Playwright** for end-to-end testing:

- **User flow testing**: Complete user journeys
- **Cross-browser testing**: Chrome, Firefox, Safari compatibility
- **Mobile testing**: Responsive design validation
- **Performance testing**: Page load and interaction speeds

### Test Structure

```typescript
// File: tests/user-management.spec.ts
import { test, expect } from '@playwright/test'

test.describe('User Management', () => {
  test.beforeEach(async ({ page }) => {
    // Navigate to login page
    await page.goto('/login')
    await page.fill('[data-testid="email"]', 'admin@omni.com')
    await page.fill('[data-testid="password"]', 'password')
    await page.click('[data-testid="login-button"]')
  })

  test('should create new user', async ({ page }) => {
    await page.goto('/users/new')
    
    await page.fill('[data-testid="user-email"]', 'newuser@example.com')
    await page.fill('[data-testid="user-name"]', 'New User')
    await page.selectOption('[data-testid="user-role"]', 'SALESPERSON')
    
    await page.click('[data-testid="save-button"]')
    
    await expect(page.locator('[data-testid="success-message"]')).toBeVisible()
  })

  test('should edit existing user', async ({ page }) => {
    // Test implementation
  })
})
```

### Running Frontend Tests

```bash
# Run all frontend tests
pnpm test:e2e

# Run tests for specific application
pnpm test:client
pnpm test:admin

# Run tests in headed mode
pnpm test:e2e:headed

# Run tests in debug mode
pnpm test:e2e:debug

# Generate test report
pnpm test:e2e:report
```

### Test Categories

#### User Authentication
- Login flows
- Session management
- Role-based access
- Logout functionality

#### Inventory Management
- Product creation
- Category management
- Stock updates
- Search and filtering

#### Multi-tenant Operations
- Tenant data isolation
- Cross-tenant security
- User permissions
- Data validation

## Test Data Management

### Backend Test Data

```typescript
// File: src/tests/fixtures/user-fixtures.ts
export const userFixtures = {
  validUser: {
    email: 'test@example.com',
    name: 'Test User',
    role: 'SUPPORT' as UserRole
  },
  
  adminUser: {
    email: 'admin@omni.com',
    name: 'Admin User',
    role: 'ADMIN' as UserRole
  }
}

// File: src/tests/helpers/test-database.ts
export const setupTestDatabase = async () => {
  // Create test database connection
  // Seed initial data
  // Return cleanup function
}
```

### Frontend Test Data

```typescript
// File: tests/fixtures/api-mocks.ts
export const mockApiResponses = {
  getUserSuccess: {
    success: true,
    data: {
      id: 'user-123',
      email: 'test@example.com',
      name: 'Test User'
    }
  },
  
  getUserError: {
    success: false,
    error: 'User not found'
  }
}
```

## Testing Scripts

### Root Package.json

```json
{
  "scripts": {
    "test": "turbo run test",
    "test:server": "turbo run test --filter=omni-server",
    "test:client": "turbo run test --filter=omni-client", 
    "test:admin": "turbo run test --filter=omni-admin",
    "test:e2e": "turbo run test:e2e",
    "test:coverage": "turbo run test:coverage",
    "test:watch": "turbo run test:watch"
  }
}
```

### Server Package.json

```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "test:ui": "vitest --ui"
  }
}
```

### Client/Admin Package.json

```json
{
  "scripts": {
    "test": "playwright test",
    "test:headed": "playwright test --headed",
    "test:debug": "playwright test --debug",
    "test:report": "playwright show-report"
  }
}
```

## Continuous Integration

### GitHub Actions

Tests run automatically on:
- **Pull requests**: All tests must pass
- **Main branch**: Full test suite execution
- **Nightly builds**: Extended test coverage
- **Release preparation**: Complete validation

### Test Coverage Requirements

- **Backend**: Minimum 80% code coverage
- **Critical paths**: 100% coverage for authentication, payments, data isolation
- **Frontend**: Key user flows covered
- **API endpoints**: All endpoints tested

## Test Environment Configuration

### Environment Variables

```bash
# Test database URLs
TEST_OMNI_DATABASE_URL="postgresql://test:test@localhost:5432/omni_test"
TEST_SHARED_DATABASE_URL="postgresql://test:test@localhost:5432/omni_shared_test"

# Test Redis
TEST_REDIS_URL="redis://localhost:6379/1"

# Test configuration
NODE_ENV="test"
LOG_LEVEL="error"
```

### Database Setup

```bash
# Create test databases
createdb omni_test
createdb omni_shared_test

# Run test migrations
npx prisma migrate dev --name init
npx prisma migrate dev --name init --schema=prisma/shared-schema.prisma
```

## Best Practices

### Writing Effective Tests

1. **Clear test names**: Describe what the test does and expects
2. **Arrange-Act-Assert**: Structure tests clearly
3. **Independent tests**: No dependencies between tests
4. **Fast execution**: Keep tests quick and focused
5. **Realistic data**: Use representative test data

### Debugging Tests

1. **Isolation**: Run single test files to identify issues
2. **Console output**: Use strategic logging for debugging
3. **Database state**: Verify test data setup and cleanup
4. **Async handling**: Proper handling of promises and timeouts

### Maintenance

1. **Regular updates**: Keep test dependencies current
2. **Refactor with code**: Update tests when refactoring application code
3. **Remove obsolete tests**: Clean up tests for removed features
4. **Documentation**: Keep test documentation current