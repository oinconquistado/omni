---
title: Project Standards
description: Development standards, conventions, and best practices for the Omni SaaS platform
---

# Project Standards

This document outlines the development standards, conventions, and best practices used throughout the Omni SaaS platform to ensure consistency, maintainability, and quality.

## Code Style & Formatting

### Biome.js Configuration

The project uses **Biome.js** for linting and formatting across all packages:

- **Linting**: Consistent code quality checks
- **Formatting**: Automatic code formatting 
- **Import Organization**: Sorted and organized imports
- **TypeScript Integration**: Full TypeScript support

### Key Rules

- **No comments** in production code unless absolutely necessary
- **Consistent indentation**: 2 spaces for all files
- **Semicolons**: Required for TypeScript/JavaScript
- **Quotes**: Double quotes for strings
- **Trailing commas**: Required in multi-line structures

## Naming Conventions

### File and Directory Naming

- **kebab-case** for all files and directories
- **PascalCase** for React components
- **camelCase** for variables and functions

Examples:
```
✅ Good:
- components/user-profile.tsx
- utils/format-currency.ts
- hooks/use-api-client.ts
- tests/user-service.test.ts

❌ Bad:
- components/UserProfile.tsx
- utils/formatCurrency.ts
- hooks/useApiClient.ts
- tests/user_service.test.ts
```

### Code Naming

- **PascalCase**: React components, TypeScript interfaces, types, enums
- **camelCase**: Variables, functions, methods, object properties
- **UPPER_SNAKE_CASE**: Constants and environment variables
- **kebab-case**: CSS classes, HTML attributes, file names

Examples:
```typescript
// Types and Interfaces
interface UserProfile {}
type ApiResponse<T> = {}
enum UserRole {}

// Variables and Functions
const userName = "john"
const API_BASE_URL = "http://localhost:3002"
function getUserById(id: string) {}

// Components
const UserDashboard = () => {}
```

## Project Structure

### Monorepo Organization

```
omni/
├── apps/
│   ├── omni-client/        # Client application
│   ├── omni-admin/         # Admin application  
│   ├── omni-server/        # API server
│   └── devdocs/            # Documentation
├── packages/
│   ├── shared-types/       # Common types
│   ├── typescript-config/  # TS configs
│   └── api-client/         # API client package
└── tools/                  # Build tools and utilities
```

### Application Structure

Each application follows a consistent structure:

```
app/
├── src/
│   ├── components/         # Reusable UI components
│   ├── pages/             # Next.js pages (if applicable)
│   ├── hooks/             # Custom React hooks
│   ├── utils/             # Utility functions
│   ├── types/             # TypeScript type definitions
│   ├── services/          # API services and business logic
│   └── tests/             # Test files
├── public/                # Static assets
├── package.json
└── tsconfig.json
```

## TypeScript Standards

### Configuration

- **Strict mode**: Enabled across all packages
- **Type safety**: No `any` types unless absolutely necessary
- **Explicit return types**: For all public functions
- **Import organization**: Grouped and sorted imports

### Type Definitions

```typescript
// Explicit return types for functions
export const getUserById = async (id: string): Promise<User | null> => {
  // Implementation
}

// Interface definitions with clear naming
interface UserCreateRequest {
  email: string
  name: string
  role?: UserRole
}

// Generic types with constraints
type ApiResponse<T = unknown> = {
  success: boolean
  data?: T
  error?: string
}
```

## Database Standards

### Schema Design

- **camelCase** for field names in TypeScript
- **snake_case** for database column names
- **Descriptive naming** for relationships and constraints
- **Tenant isolation** required for all shared schema models

### Prisma Conventions

```prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String   @map("first_name")
  createdAt DateTime @default(now()) @map("created_at")
  
  @@map("users")
}
```

## API Standards

### REST Conventions

- **Consistent response format**: Using `ApiResponse<T>` interface
- **HTTP status codes**: Proper usage across all endpoints
- **Error handling**: Standardized error responses
- **Validation**: Input validation with clear error messages

### Response Format

```typescript
// Success response
{
  success: true,
  data: {
    // Response data
  }
}

// Error response
{
  success: false,
  error: "Error message"
}
```

## Testing Standards

### Backend Testing (Vitest)

- **Unit tests**: For individual functions and methods
- **Integration tests**: For service layer and database operations
- **Test file naming**: `*.test.ts` for all test files
- **Test organization**: Group related tests using `describe` blocks

### Frontend Testing (Playwright)

- **End-to-end tests**: For critical user flows
- **Component testing**: For complex UI components
- **Test file naming**: `*.spec.ts` for Playwright tests
- **Page Object Model**: For maintainable test code

### Test Structure

```typescript
// Backend test example
describe('UserService', () => {
  describe('getUserById', () => {
    it('should return user when valid id provided', async () => {
      // Test implementation
    })
    
    it('should return null when user not found', async () => {
      // Test implementation
    })
  })
})
```

## Git Workflow

### Branch Naming

- **feature branches**: `feat/feature-name`
- **bug fixes**: `fix/bug-description`
- **documentation**: `docs/update-description`
- **refactoring**: `refactor/component-name`

### Commit Messages

Following conventional commits format:

```
feat: add user authentication system
fix: resolve database connection timeout
docs: update API documentation
refactor: improve error handling in user service
test: add unit tests for user service
```

## Documentation Standards

### Code Documentation

- **No inline comments** unless explaining complex business logic
- **Function documentation**: Use JSDoc for public APIs
- **README files**: Clear setup and usage instructions
- **Architectural decisions**: Document in devdocs

### API Documentation

- **OpenAPI/Swagger**: Auto-generated API documentation
- **Request/Response examples**: For all endpoints
- **Error scenarios**: Document all possible error responses
- **Authentication**: Clear auth requirements

## Performance Standards

### Code Performance

- **Lazy loading**: For components and routes
- **Memoization**: For expensive calculations
- **Database optimization**: Proper indexing and query optimization
- **Bundle optimization**: Tree shaking and code splitting

### Monitoring

- **Error tracking**: Comprehensive error logging
- **Performance metrics**: Response time monitoring
- **Database monitoring**: Query performance tracking
- **Cache utilization**: Redis cache hit rates

## Security Standards

### Data Protection

- **Input validation**: All user inputs validated
- **SQL injection**: Prevention through Prisma ORM
- **Authentication**: Secure session management
- **Environment variables**: Secure configuration management

### Multi-tenancy Security

- **Tenant isolation**: Strict tenant data separation
- **Access control**: Role-based permissions
- **Data validation**: Tenant-specific data validation
- **Audit logging**: Track all data access and modifications